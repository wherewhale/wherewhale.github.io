---
layout: post
title: "[추석맞이 코딩챌린지②] 정상 정복"
date: 2021-09-20 01:30:35 +0900
categories: Algorithm
---

---

<span style="color:#5CD1E5">본 글은 네이버 카페 코뮤니티에서 주최한 코딩챌린지 참여 글입니다.</span>
<br>
Naver 카페 [코뮤니티][link]
<br>
<br>
첫 번째 문제 : [[추석맞이 코딩챌린지①] 피보나치수][link1]

[link]: https://cafe.naver.com/codeuniv/44736 "코뮤니티"
[link1]: https://wherewhale.github.io/algorithm/2021/09/19/chu1.html "피보나치수"

# 1. 달팽이의 정상정복!

<br>
<img src="/assets/image/dal.png" width="30%" title="달팽이야 힘내" alt="달팽이의 정상정복"/>
<br>

두 번째 풀이 글입니다. :)
<br>두 번째는 달팽이가 정상에 올라가기까지 걸리는 시간을 확인하는 문제인데요, 조건은 다음과 같습니다.
<br>
조건 1 : 첫번째 줄에 A, B, N이 공백으로 구분되어 주어집니다.
<br>
조건 2 : 정상에 도달하는게 불가능할 경우, -1을 출력하세요. 수열은 수학에서 아래의 점화식으로 정의되는 수열입니다.
<br>

​

## 어떤 알고리즘이 필요할까?

반복문?

```c
#include <stdio.h>

int main()
{
    for (int i = 0; i < 100; i++)
    {
        printf("출력띠~ \n");
    }

    return 0;
}
```

다음과 같은 반복문은 코드의 복잡도만 증가시킬 뿐, 이번 문제의 핵심이 아닙니다.
<br>
저번 글에서 말했듯, 우리는 한 번의 연산이라도 줄여, 알고리즘을 만들어야 합니다.
<br>
즉, 위와 같이 반복문을 통해 계속적으로 연산하는 과정은 문제의 핵심을 벗어난 풀이방식이라고 볼 수 있습니다.
<br>
<br>
따라서, 이번 문제에서는 가장 짧고 간결하게 문제를 풀이할 수 있도록 하겠습니다.
<br>
숏코딩의 핵심, 수식 연산을 통해서 말이죠 :)
<br>
<br>
<br>

# 2. 정답 코드

알고리즘을 풀이하는 것에 있어, 가장 중요한 것은 나올 수 있는 상황의 종류를 정리하는 것입니다.
<br>
위 문제에서도 몇 가지 상황들이 나올 수 있어, 이 조건들을 정리하여 모든 상황에 대처할 수 있는 코드는 아래와 같습니다.

```c
#include <stdio.h>

int main(){
        int a, b, v;
        scanf("%d%d%d", &a, &b, &v);

        if(a == v){
                printf("%d", 1); //하루만에 정상에 도달할 수 있는 상황
        }
        else if(a <= b){
                printf("%d", -1); //절대 도달할 수 없는 상황
        }
        else{
                printf("%d", (v+~b)/(a-b)+1); //도달할 수 있는 상황의 연산
        }
        return 0;
}

```

<br>
위 조건식과 같이 총 세 가지의 경우가 나올 수 있습니다. :)
<br>
for, while 과 같은 반복문에서는 수차례 이뤄져야 했던 연산이 위 코드에서는 단 한 번으로 해결할 수 있게되었습니다.
<br>
<br>

> **즉, 이번 코드의 시간복잡도는 <span style="color:blue">O(1)</span>이겠군요**

<br>

<span style="color: gray; text-decoration : line-through">
뿌듯..!
</span>

<br>
<br>
# 3. 코드 원리

이번 코드에서는 수식의 길이를 줄이고자 오랜시간동안 고민했습니다.
<br>
그 결과 다음과 같은 수식을 얻을 수 있었습니다.
<br>

```c
(v+~b)/(a-b)+1); //v는 정상 높이, a는 올라가는 높이, b는 떨어지는 높이
```

<br>

여기서 ~b는 not 연산자로 b의 bit를 완전히 뒤바꿔버리는 연산자입니다.
<br>
<br>
예를 들어보겠습니다.
<br>
<br>

```c
int tmp1 = 1;
int tmp2 = 5;
int tmp3 = 16;

printf("%d \n%d \n%d", ~tmp1, ~tmp2, ~tmp3);
```

라는 코드를 작성했을 때, 결과는 아래와 같습니다.

```c
-2
-6
-17
```

<br>
이런 결과가 나온 이유는 다음과 같습니다.
<br>
<br>
1의 이진수 표현은 1
<br>
5의 이진수 표현은 101
<br>
16의 이진수 표현은 10000
<br>
<br>
이것을 완전히 뒤바꾸면
<br>
~1은 0 (-2)
<br>
~5는 010 (-6)
<br>
~16은 01111 (-17)
<br>

여기서 그냥 이진수대로 읽어버리지 않는 이유는 int가 signed로 표현된 변수이기 때문입니다.
<br>
signed와 unsigned의 차례는 제 블로그에 나중에 cs를 공부하며 포스팅해보도록 하겠습니다 ㅎㅎ;
<br>
<br>

자, 그렇다면 왜 굳이 ~(not 연산자)를 사용하면서 위 같은 수식을 만들었냐?
<br>
그 이유는 다음과 같습니다.
<br>
<br>
달팽이가 목적지에 닿을 수 있는 것을 확신하는 시점은 당일이 아닙니다.
<br>
다음날 낮이 되기 바로 직전!
<br>
즉, **<span style="color: red">닿기 전 날 밤</span>** 이라는 것입니다.

따라서, 닿기 전 날 밤의 위치가 **v - (b+1)** 에 있다면, <br>
우리는 다음날 정상에 도착할 수 있다는 것을 보장받을 수 있습니다.
<br>
<span style="color: gray">a > b 이기 때문</span>
<br>
<br>
결론적으로, v - (b+1)과 똑같이 사용할 수 있는 v+~b를 수식으로 사용하는 정당성을 부여할 수 있다는 것입니다.
<br>
위를 분자로 두고, (a-b)를 분모에 둠으로서,
<br>
정상에 닿을 수 있는 날을 보장받는 곳까지 가는 시간을 확인하면
<br>
그 다음날 도착하기 때문에, 마지막으로 +1 을 더해줌으로서, 결과가 출력되는 것입니다.
<br>

<br>
<br>
<br>

# 4. 소스코드 증명

```c
#include <stdio.h>

int main(){
        int a, b, v;
        scanf("%d%d%d", &a, &b, &v);

        if(a == v){
                printf("%d", 1); //하루만에 정상에 도달할 수 있는 상황
        }
        else if(a <= b){
                printf("%d", -1); //절대 도달할 수 없는 상황
        }
        else{
                printf("%d", (v+~b)/(a-b)+1); //도달할 수 있는 상황의 연산
        }
        return 0;
}
```

1. if

   > 정상의 높이와 달팽이가 하루에 올라갈 수 있는 높이가 같은 경우
   > <br> **_이 때의 결과는 무조건 1_**

2. else if

   > 정상의 높이가 달팽이가 하루에 올라갈 수 있는 높이가 아니며,
   > <br> 올라가는 높이보다 떨어지는 높이가 더 클 때,
   > <br> **_이 때의 결과는 무조건 -1_** <br> <span style="color: gray">정상에 못 가는 달팽쿤 ㅠ</span>

3. else
   > 3번에서 증명한 수식을 통해 결과 출력

<br>
코드의 예시 출력 결과입니다.
<br>
<img src="/assets/image/dal1.png" width="30%" title="출력 예시" alt="출력 예시"/>
<br>
<br>
<br>
<br>
<br>
이로서, 두 번째 문제도 해결해보았습니다. ㅎㅎ
<br>
프로그래머로서, 사용자의 어떠한 상황에도 대처할 수 있는 알고리즘을 만들 수 있도록 
<br>
공부를 통해 다양한 재료를 모아둬야겠다는 생각이 듭니다. ㅎㅅㅎ
<br>
<br>
<br>
오늘도 이렇게 하나를 깨닫고 하루를 보냅니다~~
그럼 오늘도 안뇽! ʕ•ﻌ•ʔ ♡

---
